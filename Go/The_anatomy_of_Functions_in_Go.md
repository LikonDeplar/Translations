# Анатомия функций в Go

Как и в JavaScript, функции в Go являются объектами первого класа. Они могут быть назначены переменным, переданы в качестве аргумента, немедленно вызваны или 
отложены для выполнения в конце.

## Что такое функция
Функция, в общем случае, представляет собой небольшой фрагмент кода, предназначенный для выполнения определенной задачи на основе некоторых входных значений. 
Мы создаем функцию, чтобы иметь возможность выполнять такую операцию в любое время и в любом месте, передовая входные значения.

Входные значения предоставляют дополнительную информацию для функции, и они являются необязательными. Функции после завершения может возвращать или не возвращать 
какой-либо результат.
В Go функция определяется с помощью ключевого слова ```func```.
```go
func dosomething() {
	fmt.Println("Hello World!")
}
```
Функция может быть вызвана из любого места внутри тела другой функции в программе. Например, у нас есть функция ```dosomething```, которая выводит символы на 
стандартный вывод.

## Cоглашение об именах функций
В Go рекомендует писать имена функций в одно слово ```foo``` или верблюжьем стиле ```fooBar```. Имена функций через подчёркивание ```foo_bar``` так же допустимы, 
но они не являются идиоматическими в Go.

## Параметры функции
Как обсуждалось ранее, функция может принимать входные значения необходимые в ходе её выполнения. Эти входные значения передаются в вызове функции и
называются аргументами.
```go
package main

import "fmt"

func greet(user string) {
	fmt.Println("Hello " + user)
}

func main() {
	greet("John Doe")
}
```
Один или несколько аргументов также могут быть переданы функции.
```go
package main

import "fmt"

func add(a int, b int) {
	c := a + b
	fmt.Println(c)
}

func main() {
	add(1, 5)
}

```
Вы можете использовать сокращенную запись параметров в случае, если несколько подряд идущих параметров имеют один и тот же тип данных.
```go
package main

import "fmt"

func add(a, b int) {
	c := a + b
	fmt.Println(c)
}

func main() {
	add(1, 5)
}
```
Функция ```add(a, b int, c float32)``` так же допустима с точки зрения синтаксиса, поскольку ```a``` и ```b``` имеют тип данных ```int```, в то время 
как ```c``` имеет тип данных ```float32```.

## Возвращаемое значение
Функция также может возвращать значение, которое может быть напечатано или присвоено другой переменной.
```go
package main

import "fmt"

func add(a, b int) int64 {
	return int64(a + b)
}

func main() {
	result := add(1, 5)
	fmt.Println(result)
}
```
В случае, если функция возвращает значение, необходимо указать тип данных возвращаемого значения сразу после скобок с параметрами функции.
В приведенной выше программе мы убедились, что возвращаемое значение соответствует типу возвращаемого значения функции, преобразовав тип результата 
(первоначально был ```int```) в ```int64```.

## Возвращение нескольких значений
В отличие от других языков программирования, в Go можно возвращать несколько значений из функции. В этом случае мы должны указать типы возвращаемых 
значений внутри круглых скобок сразу после скобок с параметрами функции.
```go
package main

import "fmt"

func addMult(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
Чтобы получить несколько значений из функции, которая возвращает несколько значений, мы должны указать переменные через запятую.

В случае если при возврате нескольких значений вас интересует только одно значение, возвращаемое функцией, вы можете присвоить такое значение(значения) ```_``` 
(пустой идентификатор), которое сохраняет значение в пустой переменной.

Это необходимо, потому что, если переменная определена, но не используется в Go, компилятор жалуется на это.
```go
package main

import "fmt"

func addMult(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	_, multRes := addMult(2, 5)
	fmt.Println(multRes)
}
```

### Именованные возвращаемые значения
Именованные возвращаемые значения - отличный способ явно указать возвращаемые переменные в самом определении функции. Эти переменные будут созданы автоматически 
и доступны внутри тела функции. Вы можете изменить значения этих переменных внутри функции.

Оператор ```return``` в конце функции необходим для возврата именованных значений. Go автоматически вернет эти переменные, когда функция выполнит оператор ```return```.
```go
package main

import "fmt"

func addMult(a, b int) (add int, mul int) {
	add = a + b
	mul = a * b

	return // necessary
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
Вы также можете комбинировать именованные возвращаемые значения, если они относятся у одному и тому же типу данных. Однако, когда мы используем именованное 
возвращаемое значение, все именованные возвращаемые значения должны быть определены с их типами данных.
```go
package main

import "fmt"

func addMult(a, b int) (add, mul int) {
	add = a + b
	mul = a * b

	return // necessary
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
функция ```math() (add, mult int, div float32)``` также является допустимой с точки зрения синтаксиса, поскольку ```add``` и ```mult``` имеют тип данных ```int```, 
в то время как ```div``` имеет тип данных ```float32```.

## Рекурсия
Функция называется рекурсивной, когда она вызывает саму себя изнутри собственного тела. Простой синтаксис рекурсивной функции
```go
func r() {
  r()
}
```
Если мы запустим описанную выше функцию r, она будет бесконечно повторяться. Следовательно, в рекурсивной функции мы обычно используем условное выражение, 
такое как if-else, чтобы выйти из бесконечной рекурсии.

Простым примером рекурсивной функции является факториал числа n. Простая рекурсивная формула для факториала n равна n * (n-1)! при условии, что n > 0.
```go
// n! = n*(n-1)! where n>0
func getFactorial(num int) int {
	if num > 1 {
		return num * getFactorial(num-1)
	} else {
		return 1 // 1! == 1
	}
}
```
Приведенная выше функция ```getFactorial``` является рекурсивной, так как мы вызываем ```getFactorial``` изнутри функции ```getFactorial```. Давайте разберемся, 
как это работает.

Когда ```getFactorial``` вызывается с параметром ```int num```, если ```num``` равно 1, функция возвращает 1, иначе она заходит внутрь блока ```if``` и выполняет 
```num * getFactorial(num-1)```.

Функция ```getFactorial``` вызывается снова, и возвращаемое значение будет удерживаться до тех пор, пока ```getFactorial``` не вернет что-либо. Этот стек будет 
продолжать создаваться до тех пор, пока ```getFactorial``` не вернет 1.
Как только это произойдет, весь стек вызовов будет разрешен один за другим, в конечном итоге разрешив первый вызов ```getFactorial```.
```go
package main

import "fmt"

// n! = n×(n-1)! where n >0
func getFactorial(num int) int {
	if num > 1 {
		return num * getFactorial(num-1)
	}

	return 1 // 1! == 1
}

func main() {
	f := getFactorial(4)
	fmt.Println(f)
}
```

## Ключевое слово defer
```defer``` - это ключевое слово в Go, которое заставляет функцию выполняться в конце выполнения родительской функции или когда родительская функция выполняет оператор ```return```.

Давайте рассмотрим этот пример, чтобы лучше понять концепцию.
```go
package main

import "fmt"

func sayDone() {
	fmt.Println("I am done")
}

func main() {
	fmt.Println("main started")

	defer sayDone()

	fmt.Println("main finished")
}
```
По мере выполнения ```main``` функции будет выведено "main started", а затем вызвана ```sayDone()```, но её выполнение отложится в списк ожидания из-за ```defer```.
Затем будет выведено "main finished", и когда функция ```main``` прекращает выполнение, выполняется ```sayDone()```.
Мы можем передавать параметры в функции ```defer```, если она их поддерживает, но есть скрытая особенность. Давайте создадим простую функцию с аргументами.
```go
package main

import "fmt"

func endTime(timestamp string) {
	fmt.Println("Program ended at", timestamp)
}

func main() {
	time := "1 PM"

	defer endTime(time)

	time = "2 PM"

	fmt.Println("doing something")
	fmt.Println("main finished")
	fmt.Println("time is", time)
}
```
В приведенной выше программе мы отложили выполнение функции EndTime(), что означает, что она будет выполнена в конце функции main, но поскольку в конце основной функции time === "2PM", мы ожидали, что будет выведено сообщение "Program ended at 2 PM". Несмотря на то, что из-за отложенного выполнения функция EndTime() выполняется в конце функции main, она была помещена в стек со всеми доступными значениями аргументов, когда переменная времени все еще составляла "1PM".

Вы можете спросить, что это за стек, о котором я говорю. Стек похож на записную книжку, в которую компилятор Go записывает отложенные функции для выполнения в конце выполнения текущей функции. Это стек в котором порядок выполнения Last In First Out (LIFO). Это означает, что задача, поставленная первой, будет выполнена в конце.

Давайте напишем несколько отложенных задач и посмотрим, что я имею в виду
```go
package main

import "fmt"

func greet(message string) {
	fmt.Println("greeting: ", message)
}

func main() {
	fmt.Println("Call one")

	defer greet("Greet one")

	fmt.Println("Call two")

	defer greet("Greet two")

	fmt.Println("Call three")

	defer greet("Greet three")
}
```
Практическое использование defer можно увидеть, когда функция содержит слишком много условий, будь то операторы if-else или case, и в конце каждого условия вам нужно сделать что-то вроде закрытия файла или отправки http-ответа. Вместо того, чтобы писать несколько вызовов, мы можем использовать отложенный вызов, чтобы сэкономить время.

Ниже приведен пример плохой программы.
```go
if cond1 {
    ...
    fs.Close(file)
} else if cond2 {
    ...
    fs.Close(file)
} else if cond3 {
    ...
    fs.Close(file)
} else {
    ...
    fs.Close(file)
}
```
Ниже приведен пример хорошей программы.
```go
defer fs.Close(file)
if cond1 {
    ...
} else if cond2 {
    ...
} else if cond3 {
    ...
} else {
    ...
}
```

## Функция как тип данных




[Оригинал статьи](https://medium.com/rungo/the-anatomy-of-functions-in-go-de56c050fe11)
