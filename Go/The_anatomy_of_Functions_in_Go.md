# Анатомия функций в Go

Как и JavaScript, функции в Go являются объектами первого класа. Они могут быть назначены переменным, переданы в качестве аргумента, немедленно вызваны или 
отложены для выполнения в конце.

## Что такое функция
Функция, в общем случае, представляет собой небольшой фрагмент кода, предназначенный для выполнения определенной задачи на основе некоторых входных значений. 
Мы создаем функцию, чтобы иметь возможность выполнять такую операцию в любое время и в любом месте, передовая входные значения.

Входные значения предоставляют дополнительную информацию для функции, и они являются необязательными. Функции после завершения может возвращать или не возвращать 
какой-либо результат.
В Go функция определяется с помощью ключевого слова ```func```.
```go
func dosomething() {
    fmt.Println("Hello World!")
}
```
Функция может быть вызвана из любого места внутри тела другой функции в программе. Например, у нас есть функция ```dosomething```, которая выводит символы на 
стандартный вывод.

## Cоглашение об именах функций
В Go рекомендует писать имена функций в одно слово ```foo``` или верблюжьем стиле ```fooBar```. Имена функций через подчёркивание ```foo_bar``` так же допустимы, 
но они не являются идиоматическими в Go.

## Параметры функции
Как обсуждалось ранее, функция может принимать входные значения необходимые в ходе её выполнения. Эти входные значения передаются в вызове функции и
называются аргументами.
```go
package main

import "fmt"

func greet(user string) {
	fmt.Println("Hello " + user)
}

func main() {
	greet("John Doe")
}
```
Один или несколько аргументов также могут быть переданы функции.
```go
package main

import "fmt"

func add(a int, b int) {
	c := a + b
	fmt.Println(c)
}

func main() {
	add(1, 5)
}

```
Вы можете использовать сокращенную запись параметров в случае, если несколько подряд идущих параметров имеют один и тот же тип данных.
```go
package main

import "fmt"

func add(a, b int) {
	c := a + b
	fmt.Println(c)
}

func main() {
	add(1, 5)
}
```
Функция ```add(a, b int, c float32)``` так же допустима с точки зрения синтаксиса, поскольку ```a``` и ```b``` имеют тип данных ```int```, в то время 
как ```c``` имеет тип данных ```float32```.

## Возвращаемое значение
Функция также может возвращать значение, которое может быть напечатано или присвоено другой переменной.
```go
package main

import "fmt"

func add(a, b int) int64 {
	return int64(a + b)
}

func main() {
	result := add(1, 5)
	fmt.Println(result)
}
```
В случае, если функция возвращает значение, необходимо указать тип данных возвращаемого значения сразу после скобок с параметрами функции.
В приведенной выше программе мы убедились, что возвращаемое значение соответствует типу возвращаемого значения функции, преобразовав тип результата 
(первоначально был ```int```) в ```int64```.

## Возвращение нескольких значений
В отличие от других языков программирования, в Go можно возвращать несколько значений из функции. В этом случае мы должны указать типы возвращаемых 
значений внутри круглых скобок сразу после скобок с параметрами функции.
```go
package main

import "fmt"

func addMult(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
Чтобы получить несколько значений из функции, которая возвращает несколько значений, мы должны указать переменные через запятую.

В случае если при возврате нескольких значений вас интересует только одно значение, возвращаемое функцией, вы можете присвоить такое значение(значения) ```_``` 
(пустой идентификатор), которое сохраняет значение в пустой переменной.

Это необходимо, потому что, если переменная определена, но не используется в Go, компилятор жалуется на это.
```go
package main

import "fmt"

func addMult(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	_, multRes := addMult(2, 5)
	fmt.Println(multRes)
}
```

### Именованные возвращаемые значения
Именованные возвращаемые значения - отличный способ явно указать возвращаемые переменные в самом определении функции. Эти переменные будут созданы автоматически 
и доступны внутри тела функции. Вы можете изменить значения этих переменных внутри функции.

Оператор ```return``` в конце функции необходим для возврата именованных значений. Go автоматически вернет эти переменные, когда функция выполнит оператор ```return```.
```go
package main

import "fmt"

func addMult(a, b int) (add int, mul int) {
	add = a + b
	mul = a * b

	return // necessary
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
Вы также можете комбинировать именованные возвращаемые значения, если они относятся у одному и тому же типу данных. Однако, когда мы используем именованное 
возвращаемое значение, все именованные возвращаемые значения должны быть определены с их типами данных.
```go
package main

import "fmt"

func addMult(a, b int) (add, mul int) {
	add = a + b
	mul = a * b

	return // necessary
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
функция ```math() (add, mult int, div float32)``` также является допустимой с точки зрения синтаксиса, поскольку ```add``` и ```mult``` имеют тип данных ```int```, 
в то время как ```div``` имеет тип данных ```float32```.

## Рекурсия
Функция называется рекурсивной, когда она вызывает саму себя изнутри собственного тела. Простой синтаксис рекурсивной функции
```go
func r() {
  r()
}
```
Если мы запустим описанную выше функцию r, она будет бесконечно повторяться. Следовательно, в рекурсивной функции мы обычно используем условное выражение, 
такое как if-else, чтобы выйти из бесконечной рекурсии.

Простым примером рекурсивной функции является факториал числа n. Простая рекурсивная формула для факториала n равна n * (n-1)! при условии, что n > 0.
```go
// n! = n*(n-1)! where n>0
func getFactorial(num int) int {
	if num > 1 {
		return num * getFactorial(num-1)
	} else {
		return 1 // 1! == 1
	}
}
```
Приведенная выше функция ```getFactorial``` является рекурсивной, так как мы вызываем ```getFactorial``` изнутри функции ```getFactorial```. Давайте разберемся, 
как это работает.

Когда ```getFactorial``` вызывается с параметром ```int num```, если ```num``` равно 1, функция возвращает 1, иначе она заходит внутрь блока ```if``` и выполняет 
```num * getFactorial(num-1)```.

Функция ```getFactorial``` вызывается снова, и возвращаемое значение будет удерживаться до тех пор, пока ```getFactorial``` не вернет что-либо. Этот стек будет 
продолжать создаваться до тех пор, пока ```getFactorial``` не вернет 1.
Как только это произойдет, весь стек вызовов будет разрешен один за другим, в конечном итоге разрешив первый вызов ```getFactorial```.
```go
package main

import "fmt"

// n! = n×(n-1)! where n >0
func getFactorial(num int) int {
	if num > 1 {
		return num * getFactorial(num-1)
	}

	return 1 // 1! == 1
}

func main() {
	f := getFactorial(4)
	fmt.Println(f)
}
```

## Ключевое слово defer




[Оригинал статьи](https://medium.com/rungo/the-anatomy-of-functions-in-go-de56c050fe11)
