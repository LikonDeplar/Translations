# Анатомия функций в Go

Как и в JavaScript, функции в Go являются объектами первого класа. Они могут быть назначены переменным, переданы в качестве аргумента, немедленно вызваны или 
отложены для выполнения в конце.

## Что такое функция
Функция, в общем случае, представляет собой небольшой фрагмент кода, предназначенный для выполнения определенной задачи на основе некоторых входных значений. 
Мы создаем функцию, чтобы иметь возможность выполнять такую операцию в любое время и в любом месте, передовая входные значения.

Входные значения предоставляют дополнительную информацию для функции, и они являются необязательными. Функции после завершения может возвращать или не возвращать 
какой-либо результат.
В Go функция определяется с помощью ключевого слова ```func```.
```go
func dosomething() {
	fmt.Println("Hello World!")
}
```
Функция может быть вызвана из любого места внутри тела другой функции в программе. Например, у нас есть функция ```dosomething```, которая выводит символы на 
стандартный вывод.

## Cоглашение об именах функций
В Go рекомендует писать имена функций в одно слово ```foo``` или верблюжьем стиле ```fooBar```. Имена функций через подчёркивание ```foo_bar``` так же допустимы, 
но они не являются идиоматическими в Go.

## Параметры функции
Как обсуждалось ранее, функция может принимать входные значения необходимые в ходе её выполнения. Эти входные значения передаются в вызове функции и
называются аргументами.
```go
package main

import "fmt"

func greet(user string) {
	fmt.Println("Hello " + user)
}

func main() {
	greet("John Doe")
}
```
Один или несколько аргументов также могут быть переданы функции.
```go
package main

import "fmt"

func add(a int, b int) {
	c := a + b
	fmt.Println(c)
}

func main() {
	add(1, 5)
}

```
Вы можете использовать сокращенную запись параметров в случае, если несколько подряд идущих параметров имеют один и тот же тип данных.
```go
package main

import "fmt"

func add(a, b int) {
	c := a + b
	fmt.Println(c)
}

func main() {
	add(1, 5)
}
```
Функция ```add(a, b int, c float32)``` так же допустима с точки зрения синтаксиса, поскольку ```a``` и ```b``` имеют тип данных ```int```, в то время 
как ```c``` имеет тип данных ```float32```.

## Возвращаемое значение
Функция также может возвращать значение, которое может быть напечатано или присвоено другой переменной.
```go
package main

import "fmt"

func add(a, b int) int64 {
	return int64(a + b)
}

func main() {
	result := add(1, 5)
	fmt.Println(result)
}
```
В случае, если функция возвращает значение, необходимо указать тип данных возвращаемого значения сразу после скобок с параметрами функции.
В приведенной выше программе мы убедились, что возвращаемое значение соответствует типу возвращаемого значения функции, преобразовав тип результата 
(первоначально был ```int```) в ```int64```.

## Возвращение нескольких значений
В отличие от других языков программирования, в Go можно возвращать несколько значений из функции. В этом случае мы должны указать типы возвращаемых 
значений внутри круглых скобок сразу после скобок с параметрами функции.
```go
package main

import "fmt"

func addMult(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
Чтобы получить несколько значений из функции, которая возвращает несколько значений, мы должны указать переменные через запятую.

В случае если при возврате нескольких значений вас интересует только одно значение, возвращаемое функцией, вы можете присвоить такое значение(значения) ```_``` 
(пустой идентификатор), которое сохраняет значение в пустой переменной.

Это необходимо, потому что, если переменная определена, но не используется в Go, компилятор жалуется на это.
```go
package main

import "fmt"

func addMult(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	_, multRes := addMult(2, 5)
	fmt.Println(multRes)
}
```

### Именованные возвращаемые значения
Именованные возвращаемые значения - отличный способ явно указать возвращаемые переменные в самом определении функции. Эти переменные будут созданы автоматически 
и доступны внутри тела функции. Вы можете изменить значения этих переменных внутри функции.

Оператор ```return``` в конце функции необходим для возврата именованных значений. Go автоматически вернет эти переменные, когда функция выполнит оператор ```return```.
```go
package main

import "fmt"

func addMult(a, b int) (add int, mul int) {
	add = a + b
	mul = a * b

	return // necessary
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
Вы также можете комбинировать именованные возвращаемые значения, если они относятся у одному и тому же типу данных. Однако, когда мы используем именованное 
возвращаемое значение, все именованные возвращаемые значения должны быть определены с их типами данных.
```go
package main

import "fmt"

func addMult(a, b int) (add, mul int) {
	add = a + b
	mul = a * b

	return // necessary
}

func main() {
	addRes, multRes := addMult(2, 5)
	fmt.Println(addRes, multRes)
}
```
функция ```math() (add, mult int, div float32)``` также является допустимой с точки зрения синтаксиса, поскольку ```add``` и ```mult``` имеют тип данных ```int```, 
в то время как ```div``` имеет тип данных ```float32```.

## Рекурсия
Функция называется рекурсивной, когда она вызывает саму себя изнутри собственного тела. Простой синтаксис рекурсивной функции
```go
func r() {
  r()
}
```
Если мы запустим описанную выше функцию r, она будет бесконечно повторяться. Следовательно, в рекурсивной функции мы обычно используем условное выражение, 
такое как if-else, чтобы выйти из бесконечной рекурсии.

Простым примером рекурсивной функции является факториал числа n. Простая рекурсивная формула для факториала n равна n * (n-1)! при условии, что n > 0.
```go
// n! = n*(n-1)! where n>0
func getFactorial(num int) int {
	if num > 1 {
		return num * getFactorial(num-1)
	} else {
		return 1 // 1! == 1
	}
}
```
Приведенная выше функция ```getFactorial``` является рекурсивной, так как мы вызываем ```getFactorial``` изнутри функции ```getFactorial```. Давайте разберемся, 
как это работает.

Когда ```getFactorial``` вызывается с параметром ```int num```, если ```num``` равно 1, функция возвращает 1, иначе она заходит внутрь блока ```if``` и выполняет 
```num * getFactorial(num-1)```.

Функция ```getFactorial``` вызывается снова, и возвращаемое значение будет удерживаться до тех пор, пока ```getFactorial``` не вернет что-либо. Этот стек будет 
продолжать создаваться до тех пор, пока ```getFactorial``` не вернет 1.
Как только это произойдет, весь стек вызовов будет разрешен один за другим, в конечном итоге разрешив первый вызов ```getFactorial```.
```go
package main

import "fmt"

// n! = n×(n-1)! where n >0
func getFactorial(num int) int {
	if num > 1 {
		return num * getFactorial(num-1)
	}

	return 1 // 1! == 1
}

func main() {
	f := getFactorial(4)
	fmt.Println(f)
}
```

## Ключевое слово defer
```defer``` - это ключевое слово в Go, которое заставляет функцию выполняться в конце выполнения родительской функции или когда родительская функция выполняет оператор ```return```.

Давайте рассмотрим этот пример, чтобы лучше понять концепцию.
```go
package main

import "fmt"

func sayDone() {
	fmt.Println("I am done")
}

func main() {
	fmt.Println("main started")

	defer sayDone()

	fmt.Println("main finished")
}
```
По мере выполнения ```main``` функции будет выведено "main started", а затем вызвана ```sayDone()```, но её выполнение отложится в списк ожидания из-за ```defer```.
Затем будет выведено "main finished", и когда функция ```main``` прекращает выполнение, выполняется ```sayDone()```.
Мы можем передавать параметры в функции ```defer```, если она их поддерживает, но есть скрытая особенность. Давайте создадим простую функцию с аргументами.
```go
package main

import "fmt"

func endTime(timestamp string) {
	fmt.Println("Program ended at", timestamp)
}

func main() {
	time := "1 PM"

	defer endTime(time)

	time = "2 PM"

	fmt.Println("doing something")
	fmt.Println("main finished")
	fmt.Println("time is", time)
}
```
В приведенной выше программе мы отложили выполнение функции EndTime(), что означает, что она будет выполнена в конце функции main, но поскольку в конце основной функции time === "2PM", мы ожидали, что будет выведено сообщение "Program ended at 2 PM". Несмотря на то, что из-за отложенного выполнения функция EndTime() выполняется в конце функции main, она была помещена в стек со всеми доступными значениями аргументов, когда переменная времени все еще составляла "1PM".

Вы можете спросить, что это за стек, о котором я говорю. Стек похож на записную книжку, в которую компилятор Go записывает отложенные функции для выполнения в конце выполнения текущей функции. Это стек в котором порядок выполнения Last In First Out (LIFO). Это означает, что задача, поставленная первой, будет выполнена в конце.

Давайте напишем несколько отложенных задач и посмотрим, что я имею в виду
```go
package main

import "fmt"

func greet(message string) {
	fmt.Println("greeting: ", message)
}

func main() {
	fmt.Println("Call one")

	defer greet("Greet one")

	fmt.Println("Call two")

	defer greet("Greet two")

	fmt.Println("Call three")

	defer greet("Greet three")
}
```
Практическое использование defer можно увидеть, когда функция содержит слишком много условий, будь то операторы if-else или case, и в конце каждого условия вам нужно сделать что-то вроде закрытия файла или отправки http-ответа. Вместо того, чтобы писать несколько вызовов, мы можем использовать отложенный вызов, чтобы сэкономить время.

Ниже приведен пример плохой программы.
```go
if cond1 {
    ...
    fs.Close(file)
} else if cond2 {
    ...
    fs.Close(file)
} else if cond3 {
    ...
    fs.Close(file)
} else {
    ...
    fs.Close(file)
}
```
Ниже приведен пример хорошей программы.
```go
defer fs.Close(file)
if cond1 {
    ...
} else if cond2 {
    ...
} else if cond3 {
    ...
} else {
    ...
}
```

## Функция как тип данных
Функции в Go также являются типом. Если две функции принимают одни и те же параметры и возвращают одни и те же значения, то эти две функции имеют один и тот же тип.
Например, сложение и вычитание, которые по отдельности принимают два целых числа типа int и возвращают целое число типа int, относятся к одному и тому же типу.
Мы уже видели некоторые определения функций, например, встроенная функция ```append``` имеет такое определение
```go
func append(slice []Type, elems ...Type) []Type
```
А функция ```prepend```, которая добавляет элементы в начале среза (расширяемый массив), имееет такое определение
```go
func prepend(slice []Type, elems ...Type) []Type
```
Следовательно ```append``` и ```prepend``` будут иметь один и тот же тип
```go
func (slice []Type, elems ...Type) []Type
```
Таким образом, в Go тело функции не имеет ничего общего с типом функции.
Но какая польза от этого типа?
Это может быть полезно, если вы передаете функцию в качестве аргумента другой функции или когда функция возвращает другую функцию, и вам нужно указать тип возвращаемого значения в определении функции.
Давайте создадим функцию сложения и вычитания и посмотрим, как они сравниваются.
```go
package main

import "fmt"

func add(a int, b int) int {
	return a + b
}

func subtract(a int, b int) int {
	return a - b
}

func main() {
	fmt.Printf("Type of function add is			%T\n", add)
	fmt.Printf("Type of function subtract is		%T\n", subtract)
}
```
Таким образом, вы можете видеть, что как функция ```add```, как и функция ```subtract``` имеют один и тот же тип ```func(int, int) int```.

Давайте создадим функцию, которая принимает два целых числа, а третий аргумент-функцию, которая выполняет математическую операцию над этими двумя числами. Мы будем использовать функцию ```add``` и ```subtract``` в качестве третьего параметра этой функции.
```go
package main

import "fmt"

func add(a int, b int) int {
	return a + b
}

func subtract(a int, b int) int {
	return a - b
}

func calc(a int, b int, f func(int, int) int) int {
	r := f(a, b)
	return r
}

func main() {
	addResult := calc(5, 3, add)
	subResult := calc(5, 3, subtract)
	fmt.Println("5+3 =", addResult)
	fmt.Println("5-3 =", subResult)
}
```
В приведенной выше программе мы определили функцию ```calc```, которая принимает в качестве аргументов a и b типа ```int``` и третий аргумент функцию ```f``` типа ```func(int, int) int```. Затем мы вызываем функцию ```f``` и передаём в эту функцию a и b в качестве аргументов.
Мы можем создать производный тип, который упростит задачу. Мы можем переписать приведенную выше программу следующим образом
```go
package main

import "fmt"

func add(a int, b int) int {
	return a + b
}

func subtract(a int, b int) int {
	return a - b
}

type CalcFunc func(int, int) int

func calc(a int, b int, f CalcFunc) int {
	r := f(a, b) // calling add(a,b) or substract(a,b)
	return r
}

func main() {
	addResult := calc(5, 3, add)
	subResult := calc(5, 3, subtract)
	fmt.Println("5+3 =", addResult)
	fmt.Println("5-3 =", subResult)
}
```
Мы также могли бы написать описанную выше программу по другому, где функция ```calc``` вместо того, чтобы принимать третий аргумент в качестве функции, принимает строку, такую как "add" или "substract", и возвращает анонимную функцию в зависимости от значения переданой строки, которую мы затем можем выполнить.

Поскольку мы поняли, что функция имеет свой собственный тип, то мы можем объявить переменную с типом function, как показано ниже.
```go
var add func(int, int) int
```
Приведенный выше синтаксис объявит переменную типа function, которая принимает два аргумента int и возвращает одно значение int. Когда вы вызовите переменную add, она вернет ноль. Это происходит потому, что функция add не имеет никакого значения.

nil является значением по умолчанию для таких типов как function, pointer, slice, interface, channel, map, etc.

## Функция как значение (анонимные функции)
Функция в Go также может быть значением. Это означает, что вы можете назначить функцию переменной.
```go
package main

import "fmt"

var add = func(a int, b int) int {
	return a + b
}

func main() {
	fmt.Println("5+3 =", add(5, 3))
}
```
В приведенной выше программе мы создали глобальную переменную ```add``` и назначили ей вновь созданную функцию. В этом случае add является анонимной функцией, поскольку она была создана из функции, у которой нет имени.

## Выражение немедленно вызываемой функции (IIFE)
Если вы пришли из мира JavaScript, вы знаете, что такое выражение немедленно вызываемой функции, но не беспокойтесь, если вы этого не знаете. В Go мы можем создать анонимную функцию, которая может быть определена и выполнена одновременно.

Как мы видели в предыдущем примере как определяется ананимная функция

Где ```add``` - это анонимная функция. Некоторые могут возразить, что это не совсем анонимно, потому что мы все еще можем ссылаться на функцию ```add``` из любой точки основной функции (в других случаях из любой точки программы). Но не в том случае, когда функция немедленно вызывается или выполняется. Давайте изменим предыдущий пример.
```go
package main

import "fmt"

func main() {
	sum := func(a int, b int) int {
		return a + b
	}(3, 5)
	
	fmt.Println("5+3 =", sum)
}
```
В приведенной выше программе посмотрите на определение функции. Первая часть от ```func``` до ```}``` определяет функцию, а затем ```(3, 5)``` выполняет ее. Следовательно, ```sum``` - это значение, возвращаемое выполнением функции. Следовательно, приведенная выше программа дает следующий результат
```5+3 = 8```

Немедленно вызываемая функция также может использоваться вне основной функции в глобальном контексте. Это может быть полезно, когда вам нужно создать глобальную переменную, используя возвращаемое значение выполнения функции, и вы не хотите раскрывать функцию другим частям вашей программы.

[Оригинал статьи](https://medium.com/rungo/the-anatomy-of-functions-in-go-de56c050fe11)
